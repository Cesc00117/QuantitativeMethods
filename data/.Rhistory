}
# para1=matrix(rep(c(0,0.25,-0.45,0.15,0,-0.3,0.39,-0.18,0,0.28,-0.49,0.3),rtimes=3),nrow=3,ncol=3*(d+1),byrow=T)
# para1=matrix(rep(c(0,0.25,-0.45,0.15,0,-0.3,0.39,-0.18,0,0.28,-0.49,0.3),rtimes=3),nrow=3,ncol=3*(d+1),byrow=T)
para=cbind(para1,para2,para3)
n.seg=3
#Simulation
burnin=500
#epsilon=matrix(rt((n+burnin)*rept0,df),ncol=rept0)*sigma0
# nn is a vector containing the change-location of each segment
nn=rep(0,n.seg)
for (j in 1:(n.seg-1)){nn[j]=n*lambda[j]}
nn[n.seg]=n
epsilon=matrix(rnorm((n+burnin)*d),ncol=d)*sigma0[1]
y=matrix(0,nrow=n+burnin,ncol=d)
#len.para is a (n.seg by 1) vector containing the order of each segment
len.para=c(1,1,1)
temp.max1=max(len.para)
y[1:temp.max1,]=epsilon[1:temp.max1,]
for (i in (temp.max1+1):(n+burnin)){
y[i,]=y[i-1,]%*%t(para[,2:(d+1)])+t(para[,1])+epsilon[i,]  # [-1] is to ignore the intercept
for (j in 2:n.seg){
y[i,]=y[i,]+(y[i-1,]%*%t(para[,(2+(j-1)*(d+1)):(j*(d+1))])-y[i-1,]%*%t(para[,(2+(j-2)*(d+1)):((j-1)*(d+1))])+t(para[,1+(j-1)*(d+1)])-t(para[,1+(j-2)*(d+1)]))*((i-burnin)>nn[j-1])
}
}
y=y[(burnin+1):(n+burnin),]
return(list(y=y,cp=c(nn)))
}
m=600
d=100
Sim=simARMA.CP(m,1)
set.seed(65)
final_point=matrix(0,ncol=15,nrow=1000)
final_estimation=matrix(0,ncol=15,nrow=1000)
final_point2=matrix(0,ncol=5,nrow=1000)
final_point3=matrix(0,ncol=5,nrow=1000)
##################################################
for(num in 1:200) {
m=600
d=100
Sim=simARMA.CP(m,1)
ts.plot(Sim$y[,1])
y1=Sim$y[3:m,1]
X=matrix(0,nrow=length(y1),ncol=d+1)
X[,1]=rep(1,length(y1))
X[,2:(d+1)]=Sim$y[2:(m-1),]
y=scale(Sim$y[3:m,], center=T, scale=F)
#print(det(t(y)%*%y*(1/n)))
group<-matrix(c(1:(length(y1)*(d+1))),nrow=d+1)
G=ncol(group)
data=t(t(X)-colMeans(X))
data1=data
n=nrow(data)
p=ncol(data)
all_index<-c(1:(ncol(group)))[1:(ncol(group)-4)]
U<-y
y_fit<-matrix(,nrow=n,ncol=d*100)
set<-c()
set_group<-c()
mse<-c()
HDBIC<-c()
set_in<-group[,1]
set_group<-c(1)
set<-c(set,set_in)
y_fit[,1:d]<-data1[,2]%*%(solve(t(data1[,2])%*%(data1[,2]))%*%t(data1[,2])%*%U)
for( k in 3:(d+1)){
data1[,set[k]]<-lm(data[,set[k]]~data1[,c(set[2:(k-1)])])$residuals
y_fit[,1:d]<-y_fit[,1:d]+data1[,set[k]]%*%(solve(t(data1[,set[k]])%*%(data1[,set[k]]))%*%t(data1[,set[k]])%*%U)
}
U<-y-y_fit[,1:d]
HDBIC<-n*log(det(t(U)%*%U*(1/n)))+length(set)*log(n)*log(d)*(log(G*(d+1))-log(log(G*(d+1))))
H=NULL
for(j in 1:(length(all_index))){
ori.X_use=X
ori.X_use[c(1:(j-1)),]=0
ori.X_use=t(t( ori.X_use)-colMeans( ori.X_use))
#H[[j]]<-solve(t(ori.X_use)%*%(ori.X_use))%*%t(ori.X_use)
for(k in 1:(d+1)){
H[[(j-1)*(d+1)+k]]<-solve(t(ori.X_use[,k])%*%(ori.X_use[,k]))%*%t(ori.X_use[,k])
}
}
for(k in 1:9){
mse<-c(); mse.v=c()
set_around=c()
for(l in 1:length(set_group)){
set_around=c(set_around,c((set_group[l]-5):(set_group[l]+5)))
}
new_set=setdiff(all_index, set_around)
cores=detectCores()
cl <- makeCluster(cores)
registerDoParallel(cl, cores=cores)
chunk.size <- (length(all_index)-2)/cores
mse <- foreach(i=1:cores, .combine='c') %dopar%
{ for(j in ((i-1)*chunk.size+1):(i*chunk.size)){
ori.X_use=X
ori.X_use[c(1:(j-1)),]=0
ori.X_use=t(t( ori.X_use)-colMeans( ori.X_use))
#beta=H[[j]]%*%U
#mse<-c(mse,sum(diag(t(U-ori.X_use%*%beta)%*%(U-ori.X_use%*%beta))))
#}
mse.v<-c(mse.v,sapply(1:(d+1), function(q) sum((U-ori.X_use[,q]%*%(H[[(j-1)*(d+1)+q]]%*%U))^2)))
}
mse.v
}
stopImplicitCluster()
stopCluster(cl)
if(k<3){plot(mse)}
#set_in<-which.min(mse)
set_in<-which.min(mse)
data_new=X
data_new[c(1:(ceiling(which.min(mse)/(d+1)-1))),]=0
#data_new[c(1:(new_set[which.min(mse[new_set])]-1)),]=0
data_new=t(t(data_new)-colMeans(data_new))
data=cbind(data,data_new[,which.min(mse)-ceiling(which.min(mse)/(d+1)-1)*(d+1)])
data1=cbind(data1,data_new[,which.min(mse)-ceiling(which.min(mse)/(d+1)-1)*(d+1)])
#data=cbind(data,data_new)
#data1=cbind(data1,data_new)
for(i in 1:length(set_in)){
#data1[,length(set)+i]<-data1[,length(set)+i]-rowSums(apply(data1[,c(1:(length(set)+i-1))],2,function(x) x%*%solve(t(x)%*%(x))%*%t(x)%*%data1[,length(set)+i]))
data1[,length(set)+i]<-lm(data1[,length(set)+i]~data1[,c(2:(length(set)+i-1))])$residuals
}
y_fit[,c((d*k+1):(d*k+d))]<-y_fit[,c((d*(k-1)+1):(d*(k-1)+d))]+data1[,(length(set)+1):(length(set)+length(set_in))]%*%solve(t(data1[,(length(set)+1):(length(set)+length(set_in))])%*%(data1[,(length(set)+1):(length(set)+length(set_in))]))%*%t(data1[,(length(set)+1):(length(set)+length(set_in))])%*%U
U<-y-y_fit[,c((d*k+1):(d*k+d))]
set<-c(set,set_in)
#print(set)
set_group<-c(set_group,new_set[which.min(mse[new_set])])
HDBIC<-c(HDBIC,n*log(det(t(U)%*%U*(1/n)))+length(set)*log(n)*log(d)*(log(G*(d+1))-log(log(G*(d+1)))))
#HDHQ<-c(HDHQ,n*log(t(U)%*%U*(1/n))+length(set)*2.01*log(log(n))*log(p))
#print(k)
#print(prod(diag(t(U)%*%(U)*(1/n))))
#print(c(set_in/(d+1),set_in-floor(set_in/(d+1))*(d+1)))
#print(log(det(t(U)%*%U*(1/n))))
}
###################################################################
#Trimming
best_set=c()
for (z in 2:(which.min(HDBIC))){
if (which.min(HDBIC)<2) {
best_set=group[,set_group[which.min(HDBIC)]]
} else {
set_del=setdiff(c(1:(100+which.min(HDBIC))),z+100)
HDBIC_del=n*log(det(t(lm(y~data[,set_del])$residuals)%*%lm(y~data[,set_del])$residuals*(1/n)))+(100+length(HDBIC[1:which.min(HDBIC)])-1)*log(n)*log(d)*(log(G*(d+1))-log(log(G*(d+1))))
if(HDBIC_del>HDBIC[which.min(HDBIC)]) {
best_set=c(best_set,set[100+z])
}
}
}
#print((sort(best_set)/(d+1))[order(sort(best_set)-floor((sort(best_set))/(d+1))*(d+1))])
#print(sort(sort(best_set)-floor((sort(best_set))/(d+1))*(d+1)))
final_point[num,1:length(sort(sort(best_set)-ceiling((sort(best_set))/(d+1)-1)*(d+1)))]=sort(sort(best_set)-floor((sort(best_set))/(d+1))*(d+1))
final_estimation[num,1:length((sort(best_set)/(d+1))[order(sort(best_set)-ceiling((sort(best_set))/(d+1)-1)*(d+1))])]=(sort(best_set)/(d+1))[order(sort(best_set)-floor((sort(best_set))/(d+1))*(d+1))]
print(num)
}
View(final_estimation)
simARMA.CP=function(n,rept0,d=100,lambda=c(0.4,0.8),sigma0=c(rep(1,times=d))){
# para1=matrix(rep(c(0,rep(0.35,times=10),rep(-0.3,times=10),rep(0,times=80),0,rep(0.1,times=10),rep(-0.17,times=10),rep(0,times=80),0,rep(-0.38,times=10),rep(0.29,times=10),rep(0,times=80)),times=30),nrow=30,ncol=3*(d+1),byrow=T)
# para2=matrix(rep(c(0,rep(0,times=10),rep(0,times=10),rep(0,times=10),rep(0.3,times=10),rep(-0.38,times=10),rep(0,times=50),0,rep(0,times=10),rep(0,times=10),rep(0,times=10),rep(0.57,times=10),rep(-0.58,times=10),rep(0,times=50),0,rep(0,times=10),rep(0,times=10),rep(0,times=10),rep(-0.42,times=10),rep(0.42,times=10),rep(0,times=50)),times=30),nrow=30,ncol=3*(d+1),byrow=T)
# para3=matrix(rep(c(0,rep(0,times=20),rep(0,times=10),rep(0,times=50),rep(0.7,times=10),rep(-0.68,times=10),0,rep(0,times=20),rep(0,times=10),rep(0,times=50),rep(-0.6,times=10),rep(0.58,times=10),0,rep(0,times=20),rep(0,times=10),rep(0,times=50),rep(-0.48,times=10),rep(0.5,times=10)),times=40),nrow=40,ncol=3*(d+1),byrow=T)
# para=rbind(para1,para2,para3)
# para1=matrix(rep(c(0,0.35,-0.7,0.2,0.75,-0.7,0.2,rep(0,times=4),0,-0.49,-0.29,0.61,-0.49,-0.08,0.61,rep(0,times=4),0,0.96,0.15,-0.4,0.66,-0.8,0.2,rep(0,times=4)),rtimes=10),nrow=10,ncol=3*(d+1),byrow=T)
# para2=matrix(rep(c(0,rep(0,times=10),rep(0,times=10),rep(0,times=10),rep(0.3,times=10),rep(-0.38,times=10),rep(0,times=50),0,rep(0,times=10),rep(0,times=10),rep(0,times=10),rep(0.57,times=10),rep(-0.58,times=10),rep(0,times=50),0,rep(0,times=10),rep(0,times=10),rep(0,times=10),rep(-0.42,times=10),rep(0.42,times=10),rep(0,times=50)),times=30),nrow=30,ncol=3*(d+1),byrow=T)
# para3=matrix(rep(c(0,rep(0,times=20),rep(0,times=10),rep(0,times=50),rep(0.7,times=10),rep(-0.68,times=10),0,rep(0,times=20),rep(0,times=10),rep(0,times=50),rep(-0.6,times=10),rep(0.58,times=10),0,rep(0,times=20),rep(0,times=10),rep(0,times=50),rep(-0.48,times=10),rep(0.5,times=10)),times=40),nrow=40,ncol=3*(d+1),byrow=T)
#para=rbind(para1)
#para1=matrix(rep(c(0,0.35,-0.7,0.2,-0.4,0.33,-0.41,rep(0,times=94),0,-0.55,0.8,-0.3,0.66,-0.7,0,rep(0,times=94),0,0.7,-0.49,0,-0.54,0.69,-0.34,rep(0,times=94),0,0.6,-0.8,0.15,-0.34,0.76,0,rep(0,times=94),0,-0.2,0.7,0,0.6,-0.8,0.35,rep(0,times=94),0,0.5,-0.36,-0.33,-0.2,0.7,0,rep(0,times=94),0,0.32,-0.81,0,0.59,0.69,-0.4,rep(0,times=94),0,0.25,0.7,-0.4,0,-0.59,0.6,rep(0,times=94),0,0,-0.5,0.6,0.56,0.76,-0.44,rep(0,times=94),
#0,0.33,-0.58,0.3,-0.48,0.76,-0.34,rep(0,times=94),0,-0.58,0.9,-0.27,0.63,-0.20,0.3,rep(0,times=94),0,0.66,0.1,0,-0.38,0.79,-0.29,rep(0,times=94),0,0.56,-0.85,0.12,-0.2,0.66,0.53,rep(0,times=94),0,-0.14,0.76,0,0.62,-0.74,0.13,rep(0,times=94),0,0.5,-0.34,-0.23,-0.14,0.16,0,rep(0,times=94)),times=20),ncol=3*(d+1),byrow=T)
para1=matrix(0,nrow=d,ncol=d+1,byrow=T)
for(m in 2:(d-2)) {
para1[1,c(2:3)]=c(0.6,-0.4)
para1[2,c(2:4)]=c(0.1,0.6,-0.4)
para1[3,c(2:5)]=c(0.1,0.1,0.6,-0.4)
para1[d-2,c((d-3):(d))]=c(0.1,0.1,0.6,-0.4)
para1[d-1,c((d-2):(d+1))]=c(0.1,0.1,0.6,-0.4)
para1[d,c((d-1):(d+1))]=c(0.1,0.1,0.6)
para1[m,m+1]=0.6
para1[m-1,m+1]=-0.4
para1[m+1,m+1]=-0.1
para1[m+2,m+1]=-0.1
}
para2=para1
for(m in c(50,51,52)) {
para2[m,m+1]=-0.52
para2[m-1,m+1]=0.35
para2[m+1,m+1]=-0.42
para2[m+2,m+1]=0.33
para2[m+3,m+1]=0.63
}
para3=para1
for(m in c(50,51,52)) {
para3[m,m+1]=0.5
para3[m-1,m+1]=-0.4
para3[m+1,m+1]=0.35
para3[m+2,m+1]=-0.43
}
# para1=matrix(rep(c(0,0.25,-0.45,0.15,0,-0.3,0.39,-0.18,0,0.28,-0.49,0.3),rtimes=3),nrow=3,ncol=3*(d+1),byrow=T)
# para1=matrix(rep(c(0,0.25,-0.45,0.15,0,-0.3,0.39,-0.18,0,0.28,-0.49,0.3),rtimes=3),nrow=3,ncol=3*(d+1),byrow=T)
para=cbind(para1,para2,para3)
n.seg=3
#Simulation
burnin=500
#epsilon=matrix(rt((n+burnin)*rept0,df),ncol=rept0)*sigma0
# nn is a vector containing the change-location of each segment
nn=rep(0,n.seg)
for (j in 1:(n.seg-1)){nn[j]=n*lambda[j]}
nn[n.seg]=n
epsilon=matrix(rnorm((n+burnin)*d),ncol=d)*sigma0[1]
y=matrix(0,nrow=n+burnin,ncol=d)
#len.para is a (n.seg by 1) vector containing the order of each segment
len.para=c(1,1,1)
temp.max1=max(len.para)
y[1:temp.max1,]=epsilon[1:temp.max1,]
for (i in (temp.max1+1):(n+burnin)){
y[i,]=y[i-1,]%*%t(para[,2:(d+1)])+t(para[,1])+epsilon[i,]  # [-1] is to ignore the intercept
for (j in 2:n.seg){
y[i,]=y[i,]+(y[i-1,]%*%t(para[,(2+(j-1)*(d+1)):(j*(d+1))])-y[i-1,]%*%t(para[,(2+(j-2)*(d+1)):((j-1)*(d+1))])+t(para[,1+(j-1)*(d+1)])-t(para[,1+(j-2)*(d+1)]))*((i-burnin)>nn[j-1])
}
}
y=y[(burnin+1):(n+burnin),]
return(list(y=y,cp=c(nn)))
}
m=600
d=100
Sim=simARMA.CP(m,1)
ts.plot(Sim$y[,1])
simARMA.CP=function(n,rept0,d=100,lambda=c(0.4,0.8),sigma0=c(rep(1,times=d))){
# para1=matrix(rep(c(0,rep(0.35,times=10),rep(-0.3,times=10),rep(0,times=80),0,rep(0.1,times=10),rep(-0.17,times=10),rep(0,times=80),0,rep(-0.38,times=10),rep(0.29,times=10),rep(0,times=80)),times=30),nrow=30,ncol=3*(d+1),byrow=T)
# para2=matrix(rep(c(0,rep(0,times=10),rep(0,times=10),rep(0,times=10),rep(0.3,times=10),rep(-0.38,times=10),rep(0,times=50),0,rep(0,times=10),rep(0,times=10),rep(0,times=10),rep(0.57,times=10),rep(-0.58,times=10),rep(0,times=50),0,rep(0,times=10),rep(0,times=10),rep(0,times=10),rep(-0.42,times=10),rep(0.42,times=10),rep(0,times=50)),times=30),nrow=30,ncol=3*(d+1),byrow=T)
# para3=matrix(rep(c(0,rep(0,times=20),rep(0,times=10),rep(0,times=50),rep(0.7,times=10),rep(-0.68,times=10),0,rep(0,times=20),rep(0,times=10),rep(0,times=50),rep(-0.6,times=10),rep(0.58,times=10),0,rep(0,times=20),rep(0,times=10),rep(0,times=50),rep(-0.48,times=10),rep(0.5,times=10)),times=40),nrow=40,ncol=3*(d+1),byrow=T)
# para=rbind(para1,para2,para3)
# para1=matrix(rep(c(0,0.35,-0.7,0.2,0.75,-0.7,0.2,rep(0,times=4),0,-0.49,-0.29,0.61,-0.49,-0.08,0.61,rep(0,times=4),0,0.96,0.15,-0.4,0.66,-0.8,0.2,rep(0,times=4)),rtimes=10),nrow=10,ncol=3*(d+1),byrow=T)
# para2=matrix(rep(c(0,rep(0,times=10),rep(0,times=10),rep(0,times=10),rep(0.3,times=10),rep(-0.38,times=10),rep(0,times=50),0,rep(0,times=10),rep(0,times=10),rep(0,times=10),rep(0.57,times=10),rep(-0.58,times=10),rep(0,times=50),0,rep(0,times=10),rep(0,times=10),rep(0,times=10),rep(-0.42,times=10),rep(0.42,times=10),rep(0,times=50)),times=30),nrow=30,ncol=3*(d+1),byrow=T)
# para3=matrix(rep(c(0,rep(0,times=20),rep(0,times=10),rep(0,times=50),rep(0.7,times=10),rep(-0.68,times=10),0,rep(0,times=20),rep(0,times=10),rep(0,times=50),rep(-0.6,times=10),rep(0.58,times=10),0,rep(0,times=20),rep(0,times=10),rep(0,times=50),rep(-0.48,times=10),rep(0.5,times=10)),times=40),nrow=40,ncol=3*(d+1),byrow=T)
#para=rbind(para1)
#para1=matrix(rep(c(0,0.35,-0.7,0.2,-0.4,0.33,-0.41,rep(0,times=94),0,-0.55,0.8,-0.3,0.66,-0.7,0,rep(0,times=94),0,0.7,-0.49,0,-0.54,0.69,-0.34,rep(0,times=94),0,0.6,-0.8,0.15,-0.34,0.76,0,rep(0,times=94),0,-0.2,0.7,0,0.6,-0.8,0.35,rep(0,times=94),0,0.5,-0.36,-0.33,-0.2,0.7,0,rep(0,times=94),0,0.32,-0.81,0,0.59,0.69,-0.4,rep(0,times=94),0,0.25,0.7,-0.4,0,-0.59,0.6,rep(0,times=94),0,0,-0.5,0.6,0.56,0.76,-0.44,rep(0,times=94),
#0,0.33,-0.58,0.3,-0.48,0.76,-0.34,rep(0,times=94),0,-0.58,0.9,-0.27,0.63,-0.20,0.3,rep(0,times=94),0,0.66,0.1,0,-0.38,0.79,-0.29,rep(0,times=94),0,0.56,-0.85,0.12,-0.2,0.66,0.53,rep(0,times=94),0,-0.14,0.76,0,0.62,-0.74,0.13,rep(0,times=94),0,0.5,-0.34,-0.23,-0.14,0.16,0,rep(0,times=94)),times=20),ncol=3*(d+1),byrow=T)
para1=matrix(0,nrow=d,ncol=d+1,byrow=T)
for(m in 2:(d-2)) {
para1[1,c(2:3)]=c(0.6,-0.4)
para1[2,c(2:4)]=c(0.1,0.6,-0.4)
para1[3,c(2:5)]=c(0.1,0.1,0.6,-0.4)
para1[d-2,c((d-3):(d))]=c(0.1,0.1,0.6,-0.4)
para1[d-1,c((d-2):(d+1))]=c(0.1,0.1,0.6,-0.4)
para1[d,c((d-1):(d+1))]=c(0.1,0.1,0.6)
para1[m,m+1]=0.6
para1[m-1,m+1]=-0.4
para1[m+1,m+1]=0.1
para1[m+2,m+1]=-0.1
}
para2=para1
for(m in c(50,51,52)) {
para2[m,m+1]=-0.52
para2[m-1,m+1]=0.35
para2[m+1,m+1]=-0.42
para2[m+2,m+1]=0.33
para2[m+3,m+1]=0.63
}
para3=para1
for(m in c(50,51,52)) {
para3[m,m+1]=0.5
para3[m-1,m+1]=-0.4
para3[m+1,m+1]=0.35
para3[m+2,m+1]=-0.43
}
# para1=matrix(rep(c(0,0.25,-0.45,0.15,0,-0.3,0.39,-0.18,0,0.28,-0.49,0.3),rtimes=3),nrow=3,ncol=3*(d+1),byrow=T)
# para1=matrix(rep(c(0,0.25,-0.45,0.15,0,-0.3,0.39,-0.18,0,0.28,-0.49,0.3),rtimes=3),nrow=3,ncol=3*(d+1),byrow=T)
para=cbind(para1,para2,para3)
n.seg=3
#Simulation
burnin=500
#epsilon=matrix(rt((n+burnin)*rept0,df),ncol=rept0)*sigma0
# nn is a vector containing the change-location of each segment
nn=rep(0,n.seg)
for (j in 1:(n.seg-1)){nn[j]=n*lambda[j]}
nn[n.seg]=n
epsilon=matrix(rnorm((n+burnin)*d),ncol=d)*sigma0[1]
y=matrix(0,nrow=n+burnin,ncol=d)
#len.para is a (n.seg by 1) vector containing the order of each segment
len.para=c(1,1,1)
temp.max1=max(len.para)
y[1:temp.max1,]=epsilon[1:temp.max1,]
for (i in (temp.max1+1):(n+burnin)){
y[i,]=y[i-1,]%*%t(para[,2:(d+1)])+t(para[,1])+epsilon[i,]  # [-1] is to ignore the intercept
for (j in 2:n.seg){
y[i,]=y[i,]+(y[i-1,]%*%t(para[,(2+(j-1)*(d+1)):(j*(d+1))])-y[i-1,]%*%t(para[,(2+(j-2)*(d+1)):((j-1)*(d+1))])+t(para[,1+(j-1)*(d+1)])-t(para[,1+(j-2)*(d+1)]))*((i-burnin)>nn[j-1])
}
}
y=y[(burnin+1):(n+burnin),]
return(list(y=y,cp=c(nn)))
}
m=600
d=100
Sim=simARMA.CP(m,1)
ts.plot(Sim$y[,1])
simARMA.CP=function(n,rept0,d=100,lambda=c(0.4,0.8),sigma0=c(rep(1,times=d))){
# para1=matrix(rep(c(0,rep(0.35,times=10),rep(-0.3,times=10),rep(0,times=80),0,rep(0.1,times=10),rep(-0.17,times=10),rep(0,times=80),0,rep(-0.38,times=10),rep(0.29,times=10),rep(0,times=80)),times=30),nrow=30,ncol=3*(d+1),byrow=T)
# para2=matrix(rep(c(0,rep(0,times=10),rep(0,times=10),rep(0,times=10),rep(0.3,times=10),rep(-0.38,times=10),rep(0,times=50),0,rep(0,times=10),rep(0,times=10),rep(0,times=10),rep(0.57,times=10),rep(-0.58,times=10),rep(0,times=50),0,rep(0,times=10),rep(0,times=10),rep(0,times=10),rep(-0.42,times=10),rep(0.42,times=10),rep(0,times=50)),times=30),nrow=30,ncol=3*(d+1),byrow=T)
# para3=matrix(rep(c(0,rep(0,times=20),rep(0,times=10),rep(0,times=50),rep(0.7,times=10),rep(-0.68,times=10),0,rep(0,times=20),rep(0,times=10),rep(0,times=50),rep(-0.6,times=10),rep(0.58,times=10),0,rep(0,times=20),rep(0,times=10),rep(0,times=50),rep(-0.48,times=10),rep(0.5,times=10)),times=40),nrow=40,ncol=3*(d+1),byrow=T)
# para=rbind(para1,para2,para3)
# para1=matrix(rep(c(0,0.35,-0.7,0.2,0.75,-0.7,0.2,rep(0,times=4),0,-0.49,-0.29,0.61,-0.49,-0.08,0.61,rep(0,times=4),0,0.96,0.15,-0.4,0.66,-0.8,0.2,rep(0,times=4)),rtimes=10),nrow=10,ncol=3*(d+1),byrow=T)
# para2=matrix(rep(c(0,rep(0,times=10),rep(0,times=10),rep(0,times=10),rep(0.3,times=10),rep(-0.38,times=10),rep(0,times=50),0,rep(0,times=10),rep(0,times=10),rep(0,times=10),rep(0.57,times=10),rep(-0.58,times=10),rep(0,times=50),0,rep(0,times=10),rep(0,times=10),rep(0,times=10),rep(-0.42,times=10),rep(0.42,times=10),rep(0,times=50)),times=30),nrow=30,ncol=3*(d+1),byrow=T)
# para3=matrix(rep(c(0,rep(0,times=20),rep(0,times=10),rep(0,times=50),rep(0.7,times=10),rep(-0.68,times=10),0,rep(0,times=20),rep(0,times=10),rep(0,times=50),rep(-0.6,times=10),rep(0.58,times=10),0,rep(0,times=20),rep(0,times=10),rep(0,times=50),rep(-0.48,times=10),rep(0.5,times=10)),times=40),nrow=40,ncol=3*(d+1),byrow=T)
#para=rbind(para1)
#para1=matrix(rep(c(0,0.35,-0.7,0.2,-0.4,0.33,-0.41,rep(0,times=94),0,-0.55,0.8,-0.3,0.66,-0.7,0,rep(0,times=94),0,0.7,-0.49,0,-0.54,0.69,-0.34,rep(0,times=94),0,0.6,-0.8,0.15,-0.34,0.76,0,rep(0,times=94),0,-0.2,0.7,0,0.6,-0.8,0.35,rep(0,times=94),0,0.5,-0.36,-0.33,-0.2,0.7,0,rep(0,times=94),0,0.32,-0.81,0,0.59,0.69,-0.4,rep(0,times=94),0,0.25,0.7,-0.4,0,-0.59,0.6,rep(0,times=94),0,0,-0.5,0.6,0.56,0.76,-0.44,rep(0,times=94),
#0,0.33,-0.58,0.3,-0.48,0.76,-0.34,rep(0,times=94),0,-0.58,0.9,-0.27,0.63,-0.20,0.3,rep(0,times=94),0,0.66,0.1,0,-0.38,0.79,-0.29,rep(0,times=94),0,0.56,-0.85,0.12,-0.2,0.66,0.53,rep(0,times=94),0,-0.14,0.76,0,0.62,-0.74,0.13,rep(0,times=94),0,0.5,-0.34,-0.23,-0.14,0.16,0,rep(0,times=94)),times=20),ncol=3*(d+1),byrow=T)
para1=matrix(0,nrow=d,ncol=d+1,byrow=T)
for(m in 2:(d-2)) {
para1[1,c(2:3)]=c(0.6,-0.4)
para1[2,c(2:4)]=c(0.1,0.6,-0.4)
para1[3,c(2:5)]=c(0.1,0.1,0.6,-0.4)
para1[d-2,c((d-3):(d))]=c(0.1,0.1,0.6,-0.4)
para1[d-1,c((d-2):(d+1))]=c(0.1,0.1,0.6,-0.4)
para1[d,c((d-1):(d+1))]=c(0.1,0.1,0.6)
para1[m,m+1]=0.6
para1[m-1,m+1]=-0.4
para1[m+1,m+1]=0.1
para1[m+2,m+1]=-0.1
}
para2=para1
for(m in c(48,50,52)) {
para2[m,m+1]=-0.52
para2[m-1,m+1]=0.35
para2[m+1,m+1]=-0.42
para2[m+2,m+1]=0.33
para2[m+3,m+1]=0.63
}
para3=para1
for(m in c(48,50,52)) {
para3[m,m+1]=0.5
para3[m-1,m+1]=-0.4
para3[m+1,m+1]=0.35
para3[m+2,m+1]=-0.43
}
# para1=matrix(rep(c(0,0.25,-0.45,0.15,0,-0.3,0.39,-0.18,0,0.28,-0.49,0.3),rtimes=3),nrow=3,ncol=3*(d+1),byrow=T)
# para1=matrix(rep(c(0,0.25,-0.45,0.15,0,-0.3,0.39,-0.18,0,0.28,-0.49,0.3),rtimes=3),nrow=3,ncol=3*(d+1),byrow=T)
para=cbind(para1,para2,para3)
n.seg=3
#Simulation
burnin=500
#epsilon=matrix(rt((n+burnin)*rept0,df),ncol=rept0)*sigma0
# nn is a vector containing the change-location of each segment
nn=rep(0,n.seg)
for (j in 1:(n.seg-1)){nn[j]=n*lambda[j]}
nn[n.seg]=n
epsilon=matrix(rnorm((n+burnin)*d),ncol=d)*sigma0[1]
y=matrix(0,nrow=n+burnin,ncol=d)
#len.para is a (n.seg by 1) vector containing the order of each segment
len.para=c(1,1,1)
temp.max1=max(len.para)
y[1:temp.max1,]=epsilon[1:temp.max1,]
for (i in (temp.max1+1):(n+burnin)){
y[i,]=y[i-1,]%*%t(para[,2:(d+1)])+t(para[,1])+epsilon[i,]  # [-1] is to ignore the intercept
for (j in 2:n.seg){
y[i,]=y[i,]+(y[i-1,]%*%t(para[,(2+(j-1)*(d+1)):(j*(d+1))])-y[i-1,]%*%t(para[,(2+(j-2)*(d+1)):((j-1)*(d+1))])+t(para[,1+(j-1)*(d+1)])-t(para[,1+(j-2)*(d+1)]))*((i-burnin)>nn[j-1])
}
}
y=y[(burnin+1):(n+burnin),]
return(list(y=y,cp=c(nn)))
}
set.seed(65)
final_point=matrix(0,ncol=15,nrow=1000)
final_estimation=matrix(0,ncol=15,nrow=1000)
final_point2=matrix(0,ncol=5,nrow=1000)
final_point3=matrix(0,ncol=5,nrow=1000)
for(num in 1:200) {
m=600
d=100
Sim=simARMA.CP(m,1)
ts.plot(Sim$y[,1])
y1=Sim$y[3:m,1]
X=matrix(0,nrow=length(y1),ncol=d+1)
X[,1]=rep(1,length(y1))
X[,2:(d+1)]=Sim$y[2:(m-1),]
y=scale(Sim$y[3:m,], center=T, scale=F)
#print(det(t(y)%*%y*(1/n)))
group<-matrix(c(1:(length(y1)*(d+1))),nrow=d+1)
G=ncol(group)
data=t(t(X)-colMeans(X))
data1=data
n=nrow(data)
p=ncol(data)
all_index<-c(1:(ncol(group)))[1:(ncol(group)-4)]
U<-y
y_fit<-matrix(,nrow=n,ncol=d*100)
set<-c()
set_group<-c()
mse<-c()
HDBIC<-c()
set_in<-group[,1]
set_group<-c(1)
set<-c(set,set_in)
y_fit[,1:d]<-data1[,2]%*%(solve(t(data1[,2])%*%(data1[,2]))%*%t(data1[,2])%*%U)
for( k in 3:(d+1)){
data1[,set[k]]<-lm(data[,set[k]]~data1[,c(set[2:(k-1)])])$residuals
y_fit[,1:d]<-y_fit[,1:d]+data1[,set[k]]%*%(solve(t(data1[,set[k]])%*%(data1[,set[k]]))%*%t(data1[,set[k]])%*%U)
}
U<-y-y_fit[,1:d]
HDBIC<-n*log(det(t(U)%*%U*(1/n)))+length(set)*log(n)*log(d)*(log(G*(d+1))-log(log(G*(d+1))))
H=NULL
for(j in 1:(length(all_index))){
ori.X_use=X
ori.X_use[c(1:(j-1)),]=0
ori.X_use=t(t( ori.X_use)-colMeans( ori.X_use))
#H[[j]]<-solve(t(ori.X_use)%*%(ori.X_use))%*%t(ori.X_use)
for(k in 1:(d+1)){
H[[(j-1)*(d+1)+k]]<-solve(t(ori.X_use[,k])%*%(ori.X_use[,k]))%*%t(ori.X_use[,k])
}
}
for(k in 1:9){
mse<-c(); mse.v=c()
set_around=c()
for(l in 1:length(set_group)){
set_around=c(set_around,c((set_group[l]-5):(set_group[l]+5)))
}
new_set=setdiff(all_index, set_around)
cores=detectCores()
cl <- makeCluster(cores)
registerDoParallel(cl, cores=cores)
chunk.size <- (length(all_index)-2)/cores
mse <- foreach(i=1:cores, .combine='c') %dopar%
{ for(j in ((i-1)*chunk.size+1):(i*chunk.size)){
ori.X_use=X
ori.X_use[c(1:(j-1)),]=0
ori.X_use=t(t( ori.X_use)-colMeans( ori.X_use))
#beta=H[[j]]%*%U
#mse<-c(mse,sum(diag(t(U-ori.X_use%*%beta)%*%(U-ori.X_use%*%beta))))
#}
mse.v<-c(mse.v,sapply(1:(d+1), function(q) sum((U-ori.X_use[,q]%*%(H[[(j-1)*(d+1)+q]]%*%U))^2)))
}
mse.v
}
stopImplicitCluster()
stopCluster(cl)
if(k<3){plot(mse)}
#set_in<-which.min(mse)
set_in<-which.min(mse)
data_new=X
data_new[c(1:(ceiling(which.min(mse)/(d+1)-1))),]=0
#data_new[c(1:(new_set[which.min(mse[new_set])]-1)),]=0
data_new=t(t(data_new)-colMeans(data_new))
data=cbind(data,data_new[,which.min(mse)-ceiling(which.min(mse)/(d+1)-1)*(d+1)])
data1=cbind(data1,data_new[,which.min(mse)-ceiling(which.min(mse)/(d+1)-1)*(d+1)])
#data=cbind(data,data_new)
#data1=cbind(data1,data_new)
for(i in 1:length(set_in)){
#data1[,length(set)+i]<-data1[,length(set)+i]-rowSums(apply(data1[,c(1:(length(set)+i-1))],2,function(x) x%*%solve(t(x)%*%(x))%*%t(x)%*%data1[,length(set)+i]))
data1[,length(set)+i]<-lm(data1[,length(set)+i]~data1[,c(2:(length(set)+i-1))])$residuals
}
y_fit[,c((d*k+1):(d*k+d))]<-y_fit[,c((d*(k-1)+1):(d*(k-1)+d))]+data1[,(length(set)+1):(length(set)+length(set_in))]%*%solve(t(data1[,(length(set)+1):(length(set)+length(set_in))])%*%(data1[,(length(set)+1):(length(set)+length(set_in))]))%*%t(data1[,(length(set)+1):(length(set)+length(set_in))])%*%U
U<-y-y_fit[,c((d*k+1):(d*k+d))]
set<-c(set,set_in)
#print(set)
set_group<-c(set_group,new_set[which.min(mse[new_set])])
HDBIC<-c(HDBIC,n*log(det(t(U)%*%U*(1/n)))+length(set)*log(n)*log(d)*(log(G*(d+1))-log(log(G*(d+1)))))
#HDHQ<-c(HDHQ,n*log(t(U)%*%U*(1/n))+length(set)*2.01*log(log(n))*log(p))
#print(k)
#print(prod(diag(t(U)%*%(U)*(1/n))))
#print(c(set_in/(d+1),set_in-floor(set_in/(d+1))*(d+1)))
#print(log(det(t(U)%*%U*(1/n))))
}
###################################################################
#Trimming
best_set=c()
for (z in 2:(which.min(HDBIC))){
if (which.min(HDBIC)<2) {
best_set=group[,set_group[which.min(HDBIC)]]
} else {
set_del=setdiff(c(1:(100+which.min(HDBIC))),z+100)
HDBIC_del=n*log(det(t(lm(y~data[,set_del])$residuals)%*%lm(y~data[,set_del])$residuals*(1/n)))+(100+length(HDBIC[1:which.min(HDBIC)])-1)*log(n)*log(d)*(log(G*(d+1))-log(log(G*(d+1))))
if(HDBIC_del>HDBIC[which.min(HDBIC)]) {
best_set=c(best_set,set[100+z])
}
}
}
#print((sort(best_set)/(d+1))[order(sort(best_set)-floor((sort(best_set))/(d+1))*(d+1))])
#print(sort(sort(best_set)-floor((sort(best_set))/(d+1))*(d+1)))
final_point[num,1:length(sort(sort(best_set)-ceiling((sort(best_set))/(d+1)-1)*(d+1)))]=sort(sort(best_set)-floor((sort(best_set))/(d+1))*(d+1))
final_estimation[num,1:length((sort(best_set)/(d+1))[order(sort(best_set)-ceiling((sort(best_set))/(d+1)-1)*(d+1))])]=(sort(best_set)/(d+1))[order(sort(best_set)-floor((sort(best_set))/(d+1))*(d+1))]
print(num)
}
install.packages("timeData")
library(fBasics)
install.packages("fBasics")
library(fBasics)
da=read.table("m-ibm-6815.txt",header=T)
setwd("C:/金融计算与模拟/CHAPTER 1/data")
da=read.table("m-ibm-6815.txt",header=T)
head(da)
ibm=da$RET
log(ibm+1)
skewness(ibm)
kurtosis(ibm)
InIBM=log(ibm+1)
t.test(InIBM)
n=100; t=1:n; x=5-2*t+3*t∧2-4*t∧3+10*rnorm(n) d1=diff(x);d2=diff(d1);d3=diff(d2);d4=diff(d3);d5=diff(d4) par(mfrow=c(2,3)) ts.plot(x);ts.plot(d1);ts.plot(d2);ts.plot(d3);ts.plot(d4);ts.plot(d5)
n=100;
t=1:n;
x=5-2*t+3*t∧2-4*t∧3+10*rnorm(n)
5-2*t
3*t∧2-
3*t
t^2
x=5-2*t+3*t^2-4*t^3+10*rnorm(n)
d1=diff(x)
d2=diff(d1)
d3=diff(d2)
d4=diff(d3)
d5=diff(d4)
par(mfrow=c(2,3))
ts.plot(x)
ts.plot(d1)
ts.plot(d2)
ts.plot(d3)
ts.plot(d4)
ts.plot(d5)
